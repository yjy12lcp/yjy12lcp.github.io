---
title: "ğŸ“– Papers"
subtitle: "æ¢ç´¢å‰æ²¿ï¼Œå»ºç«‹çŸ¥è¯†å›¾è°±"
page-layout: full
listing:
  id: papers-listing
  contents: "../posts/papers/**/index.qmd"
  sort: "date desc"
  categories: true
  filter-ui: true
  page-size: 12
  type: default
---

::: {.paper-network-container}

::: {.network-title}
Knowledge Graph
:::

::: {#paper-network-3d .paper-network-3d}
:::

::: {.network-hint}
ğŸ–±ï¸ ç§»åŠ¨é¼ æ ‡æ—‹è½¬è§†è§’ | æ‚¬åœæ°”æ³¡æŸ¥çœ‹è®ºæ–‡ | ç‚¹å‡»è¿›å…¥è¯¦æƒ…
:::

:::

::: {.papers-stats}

::: {.stat-card}
[ğŸ“š]{.stat-icon}
[<span id="paper-count">0</span>]{.stat-value}
[è®ºæ–‡ç¬”è®°]{.stat-desc}
:::

::: {.stat-card}
[ğŸ·ï¸]{.stat-icon}
[<span id="category-count">0</span>]{.stat-value}
[ç ”ç©¶é¢†åŸŸ]{.stat-desc}
:::

::: {.stat-card}
[ğŸ“…]{.stat-icon}
[<span id="latest-date">-</span>]{.stat-value}
[æœ€è¿‘æ›´æ–°]{.stat-desc}
:::

:::

---

## ğŸ“‘ All Papers

ä½¿ç”¨ **åˆ†ç±»** ç­›é€‰ç ”ç©¶é¢†åŸŸï¼Œæˆ–ç›´æ¥æœç´¢å…³é”®è¯ã€‚

::: {#papers-listing}
:::

```{=html}
<script>
document.addEventListener('DOMContentLoaded', function() {
  // å»¶è¿Ÿæ‰§è¡Œï¼Œç¡®ä¿ listing å·²æ¸²æŸ“
  setTimeout(function() {
    // ========== æŸ¥æ‰¾ listing ä¸­çš„æ–‡ç«  ==========
    const listingContainer = document.getElementById('papers-listing');
    if (!listingContainer) {
      console.log('Listing container not found');
      return;
    }
    
    // æ›´é€šç”¨çš„é€‰æ‹©å™¨ - æŸ¥æ‰¾æ‰€æœ‰æ–‡ç« é¡¹
    const listingItems = listingContainer.querySelectorAll('.quarto-post, .list-item, [class*="listing-item"], .card, .g-col-1, article, .quarto-grid-item');
    console.log('Found listing items:', listingItems.length);
    
    // å¦‚æœä¸Šé¢çš„é€‰æ‹©å™¨æ²¡æ‰¾åˆ°ï¼Œå°è¯•æŸ¥æ‰¾æ‰€æœ‰é“¾æ¥
    let papers = [];
    
    if (listingItems.length > 0) {
      listingItems.forEach((item) => {
        // æŸ¥æ‰¾æ ‡é¢˜é“¾æ¥
        const titleEl = item.querySelector('a.title, .listing-title a, .card-title a, h3 a, h2 a, .title a, a[href*="posts"]');
        const categoryEls = item.querySelectorAll('.listing-category, .quarto-category, .category, [class*="category"]');
        const dateEl = item.querySelector('.listing-date, .date, [class*="date"], time');
        
        if (titleEl) {
          const categories = [];
          categoryEls.forEach(c => categories.push(c.textContent.trim()));
          
          papers.push({
            title: titleEl.textContent.trim(),
            url: titleEl.href,
            category: categories.length > 0 ? categories[0] : 'æœªåˆ†ç±»',
            date: dateEl ? dateEl.textContent.trim() : ''
          });
        }
      });
    }
    
    // å¤‡ç”¨æ–¹æ¡ˆï¼šç›´æ¥æŸ¥æ‰¾æ‰€æœ‰æ–‡ç« é“¾æ¥
    if (papers.length === 0) {
      const allLinks = listingContainer.querySelectorAll('a[href*="posts/papers"]');
      allLinks.forEach(link => {
        if (link.textContent.trim() && !link.classList.contains('listing-category')) {
          papers.push({
            title: link.textContent.trim(),
            url: link.href,
            category: 'è®ºæ–‡',
            date: ''
          });
        }
      });
    }
    
    console.log('Found papers:', papers.length, papers);
    
    // ========== æ›´æ–°ç»Ÿè®¡æ•°å­— ==========
    const paperCountEl = document.getElementById('paper-count');
    if (paperCountEl) {
      paperCountEl.textContent = papers.length;
    }
    
    // ç»Ÿè®¡åˆ†ç±»
    const categories = new Set();
    papers.forEach(p => {
      if (p.category) categories.add(p.category);
    });
    const categoryCountEl = document.getElementById('category-count');
    if (categoryCountEl) {
      categoryCountEl.textContent = categories.size;
    }
    
    // æœ€è¿‘æ›´æ–°
    if (papers.length > 0 && papers[0].date) {
      const latestDateEl = document.getElementById('latest-date');
      if (latestDateEl) {
        latestDateEl.textContent = papers[0].date.slice(0, 7) || '-';
      }
    }
    
    // ========== 3D æ°”æ³¡ç½‘ç»œ ==========
    const container = document.getElementById('paper-network-3d');
    if (!container) return;
    
    // å¦‚æœæ²¡æœ‰è®ºæ–‡ï¼Œæ˜¾ç¤ºç¤ºä¾‹
    if (papers.length === 0) {
      papers.push(
        { title: 'å‘å¸ƒä½ çš„ç¬¬ä¸€ç¯‡è®ºæ–‡ç¬”è®°', url: '#', category: 'å¼€å§‹' }
      );
    }
    
    // åˆ›å»º 3D åœºæ™¯
    const scene = document.createElement('div');
    scene.className = 'bubble-scene';
    container.appendChild(scene);
    
    // ç”Ÿæˆæ°”æ³¡
    const radius = 100;
    papers.forEach((paper, i) => {
      const bubble = document.createElement('a');
      bubble.className = 'paper-bubble';
      bubble.href = paper.url;
      
      // çƒé¢åˆ†å¸ƒ
      const total = papers.length;
      const phi = Math.acos(-1 + (2 * i + 1) / total);
      const theta = Math.sqrt(total * Math.PI) * phi;
      
      const x = radius * Math.cos(theta) * Math.sin(phi);
      const y = radius * Math.sin(theta) * Math.sin(phi);
      const z = radius * Math.cos(phi);
      
      bubble.style.setProperty('--x', x + 'px');
      bubble.style.setProperty('--y', y + 'px');
      bubble.style.setProperty('--z', z + 'px');
      
      const shortTitle = paper.title.length > 15 ? paper.title.slice(0, 15) + '...' : paper.title;
      bubble.innerHTML = '<span class="bubble-dot"></span><span class="bubble-label">' + shortTitle + '</span>';
      
      scene.appendChild(bubble);
    });
    
    // ä¸­å¿ƒèŠ‚ç‚¹
    const centerBubble = document.createElement('div');
    centerBubble.className = 'center-bubble';
    centerBubble.innerHTML = 'ğŸ§ ';
    scene.appendChild(centerBubble);
    
    // é¼ æ ‡è·Ÿéšæ—‹è½¬
    let rotateX = 0, rotateY = 0;
    let targetRotateX = 0, targetRotateY = 0;
    
    container.addEventListener('mousemove', (e) => {
      const rect = container.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      targetRotateY = ((e.clientX - centerX) / rect.width) * 25;
      targetRotateX = -((e.clientY - centerY) / rect.height) * 25;
    });
    
    container.addEventListener('mouseleave', () => {
      targetRotateX = 0;
      targetRotateY = 0;
    });
    
    function animate() {
      rotateX += (targetRotateX - rotateX) * 0.08;
      rotateY += (targetRotateY - rotateY) * 0.08;
      scene.style.transform = 'rotateX(' + rotateX + 'deg) rotateY(' + rotateY + 'deg)';
      requestAnimationFrame(animate);
    }
    animate();
    
  }, 500); // å»¶è¿Ÿ 500ms ç­‰å¾… listing æ¸²æŸ“
});
</script>
```
